<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>KMP与字符串Hash</title>
    <link href="/2023/10/19/KMP%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2Hash/"/>
    <url>/2023/10/19/KMP%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2Hash/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP与字符串Hash"><a href="#KMP与字符串Hash" class="headerlink" title="KMP与字符串Hash"></a>KMP与字符串Hash</h1><p>最近学习算法时，在KMP和字符哈希上遇到了一些困难。这篇笔记记录整理对于KMP与字符串哈希的一些个人理解，供自己复习使用。</p><hr><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>模板题：给定一个字符串S，以及一个模式串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模式串P在字符串S中多次作为子串出现。<br><strong>求出模式串P在字符串S中所有出现的位置的起始下标。</strong></p><p>对于KMP这一个复杂的算法，个人认为在理解上有两个难点，一个是<em><strong>next</strong></em>数组的求解，另一个是利用next数组对于KMP算法的实现。</p><h3 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h3><ul><li>假设有一个字符串s(下标从0开始)，那么它以i号位作为结尾的<strong>子串</strong>就是<code>s[0:i]</code><ul><li>对于子串s,长度为k+1的<strong>前缀</strong>和<strong>后缀</strong>就是<code>s[0:k]</code>和<code>s[i-k:i]</code></li></ul></li></ul><p>构造一个int数组<strong>next</strong>。其中，<code>next[i]</code>表示使子串<code>s[0:i]</code>中的<strong>前缀</strong>和<strong>后缀</strong>相等的最大的k，即满足<code>s[0:k] == s[i-k:i]</code>的最大的k。</p><ul><li>相等的前缀和后缀不能是整个字符串，即k不能等于i</li><li>如果不存在这样的k，那么<code>next[i] = -1</code></li><li><code>next[i]</code>就是所求最长相等前后缀中前缀的最后一个字符的下标</li></ul><h3 id="用递推求解-next-数组"><a href="#用递推求解-next-数组" class="headerlink" title="用递推求解 next 数组"></a>用递推求解 next 数组</h3><p>递推求解，即已知<code>next[0]</code>~&#96;next[i-1]<code>，求解</code>next[i]&#96;。</p><ul><li>如果<code>s[next[i-1]+1] == s[i]</code>，那么<code>next[i] = next[i-1] + 1</code></li><li>否则，令<code>k = next[i-1]</code>，如果<code>s[next[k]+1] == s[i]</code>，那么<code>next[i] = next[k] + 1</code>，否则继续令<code>k = next[k]</code>，直到<code>k = -1</code>或者<code>s[next[k]+1] == s[i]</code>为止。</li></ul><p>看一个例子：<br>现在让 s &#x3D; “abababc”</p><ol><li>假设已经有了next[0]~next[3],求解next[4]<img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202310190107783.png"/></li></ol><ul><li>当已经得到 next[3] &#x3D; 1 时，最长相等前后缀为 “ab”，之后计算 next[4] 时，由于 s[4] &#x3D;&#x3D; s[next[3] + 1] (这里的为什么要用 next[3]？想想至尊概念)，因此可以把最长相等前后缀 “ab” 扩展为 “aba”，因此 next[4] &#x3D; next[3] + 1，并令 j 指向 next[4]。</li></ul><ol start="2"><li>假设已经有了next[0]~next[4],求解next[5]</li></ol><p><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202310190117515.png"><br><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202310190119598.png"/></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">-1</span>; i &lt; len; i ++)<span class="hljs-comment">// j 表示i-1号位的最长相等前后缀的前缀的最后一个字符的下标</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (j != <span class="hljs-number">-1</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 前后缀匹配不成功</span><br>    &#123;<br>        <span class="hljs-comment">// 反复令 j 回退到 -1，或是 s[i] == s[j + 1]</span><br>        j = next[j];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 匹配成功</span><br>    &#123;<br>        j ++; <span class="hljs-comment">// 最长相等前后缀变长</span><br>    &#125;<br>    next[i] = j; <span class="hljs-comment">// 令 next[i] = j</span><br>&#125;   <br></code></pre></td></tr></table></figure><h3 id="认识KMP"><a href="#认识KMP" class="headerlink" title="认识KMP"></a>认识KMP</h3><p>从一个例子开始，让 <strong>s &#x3D; “abababaabc”</strong>, <strong>p &#x3D; “ababaab”</strong></p><ul><li>令 i 指向 text 的当前欲比较位，令 j 指向 pattern 中当前已被匹配的最后位<ul><li>这样只要 text[i] &#x3D;&#x3D; pattern[j + 1] 成立，就说明 pattern[j + 1] 也被成功匹配</li></ul></li><li>直到 j 达到 m - 1(m 为 pattern 长度) 时说明 pattern 是 text 的子串</li></ul><p>下面是p[3+1]与s[4]匹配成功的情况：<br><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202310191351233.png"/></p><p>下面是p[4+1]与s[5]匹配失败后KMP的处理：<br><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202310191353300.png"/></p><p><font size = 2>Remark: KMP的核心就是当匹配失败或者匹配完整个Pattern子串后，将j&#x3D;-1从头遍历改为j&#x3D;next[j],减少时间上的开销</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>; i &lt; m; i ++)<br>    &#123;<br>       <span class="hljs-keyword">while</span> (j != <span class="hljs-number">-1</span> &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>])<br>       &#123;<br>           j = ne[j];<br>       &#125;<br>       <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>])<br>       &#123;<br>           j ++; <span class="hljs-comment">// 匹配成功时，模板串指向下一位</span><br>       &#125;<br>       <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>) <span class="hljs-comment">// 模板串匹配完成，第一个匹配字符下标为 0，故到 n - 1</span><br>       &#123;<br>           <span class="hljs-comment">// 匹配成功时，文本串结束位置减去模式串长度即为起始位置</span><br>           cout &lt;&lt; i - j &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>           <span class="hljs-comment">// 模板串在模式串中出现的位置可能是重叠的</span><br>           <span class="hljs-comment">// 需要让 j 回退到一定位置，再让 i 加 1 继续进行比较</span><br>           <span class="hljs-comment">// 回退到 ne[j] 可以保证 j 最大，即已经成功匹配的部分最长</span><br>           j = ne[j]; <br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="KMP的时间复杂度"><a href="#KMP的时间复杂度" class="headerlink" title="KMP的时间复杂度"></a>KMP的时间复杂度</h3><p>结论：KMP的时间复杂度为 $O(m+n)$<br>首先在整个for循环中，step&#x3D;1，所以i的变化次数是 $O(m)$ ，考虑j的变化次数，j最多增加m次或者减少m次，所以j的变化次数也是 $O(m)$。<br>考虑到计算next数组需要 $O(n)$的复杂度，所以整个算法的时间复杂度为 $O(m+n)$ 。</p><hr><h2 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h2><h3 id="什么是字符串哈希"><a href="#什么是字符串哈希" class="headerlink" title="什么是字符串哈希"></a>什么是字符串哈希</h3><p>字符串哈希就是将字符串映射到一个整数上，这个整数就是字符串的哈希值。</p><ul><li>把字符串看成是一个 P 进制数，每个字符的 ASCII 码对应数的一位<ul><li>经验上将P取131或13331，避免冲突（字符串哈希不考虑冲突的问题）</li></ul></li><li>字符串很长，对应的数太大，通过 $mod(2^{64})$ 把它映射到 $[0,2^{64}-1]$</li><li>用 <code>unsigned long long</code> 存储，溢出相当于对 2^64 取模，省略了手动运算</li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> h[N], p[N]; <span class="hljs-comment">// h[i]存储字符串前i个字母的哈希值, p[i]存储 P^i</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hash_init</span><span class="hljs-params">(<span class="hljs-type">char</span> str[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++ )<br>    &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>知识整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经济学导论Revision</title>
    <link href="/2023/06/01/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%AF%BC%E8%AE%BARevision/"/>
    <url>/2023/06/01/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%AF%BC%E8%AE%BARevision/</url>
    
    <content type="html"><![CDATA[<h1 id="经济学导论Revision"><a href="#经济学导论Revision" class="headerlink" title="经济学导论Revision"></a>经济学导论Revision</h1><hr><!-- # 宏观部分 --><h2 id="一、货币体系"><a href="#一、货币体系" class="headerlink" title="一、货币体系"></a>一、货币体系</h2><div style="display: grid; grid-template-columns: 1fr 1fr;">  <div><h3 id="什么是货币"><a href="#什么是货币" class="headerlink" title="什么是货币"></a>什么是货币</h3><ul><li><p><strong>货币定义</strong>：货币是经济中人们经常用于向其他人购买物品和服务的一组资产。</p></li><li><p><strong>货币职能</strong>：交换媒介（买东西） 、计价单位（价格） 、价值储存（储蓄）</p></li><li><p><strong>流动性</strong></p><ul><li>定义：流动性是一种资产转换为经济中交换媒介的容易程度</li><li>现金（通货）&gt;活期存款&gt;股票&#x2F;债券&gt;房产</li><li>分类：<ul><li>M0：通货</li><li>M1：通货+活期存款</li><li>M2：M1+小额定期存款+货币市场共同基金+其他存款</li></ul></li></ul></li><li><p><strong>货币量</strong>：经济中流通的货币量（货币存量）</p></li><li><p><strong>最主要的货币</strong>：公众手中的通货（纸币和铸币）和活期存款（支票和借记卡）</p></div><div></li></ul><h3 id="中央银行与货币创造"><a href="#中央银行与货币创造" class="headerlink" title="中央银行与货币创造"></a>中央银行与货币创造</h3><ul><li><strong>中央银行</strong>：为了监管银行体系和调节经济中的货币量而设计的机构<ul><li>职能：监管银行体系、发行该国货币、并接受各商业银行存款。掌握一个国家的外汇储备</li><li>人民银行是中国的中央银行；美联储是美国的中央银行</li></ul></li></ul><ol><li>中央银行的两项任务之二是<strong>控制经济中可得到的货币量</strong>，这种货币量称为<strong>货币供给</strong></li><li>决策者关于货币供给的政策构成各国的<strong>货币政策</strong></li></ol><ul><li><strong>商业银行</strong><ul><li><strong>银行准备金</strong>：银行已收到但尚未贷出的存款</li><li><strong>法定准备金</strong>：中央银行规定银行必须持有的准备金量的最低水平</li><li><strong>超额准备金</strong>：持有高于法定最低量的准备金</li><li><strong>准备金率</strong>： $R&#x3D;\frac{银行持有准备金}{银行存款总额}$ </div></li></ul></li></ul></div><div style="display: grid; grid-template-columns: 1fr 1fr;">  <div><hr><h3 id="货币政策"><a href="#货币政策" class="headerlink" title="货币政策"></a>货币政策</h3><p>  <strong>定义</strong>：指中央银行为实现其特定的经济目标而采用的各种<strong>控制和调节货币供应量和信用量的方针、政策和措施</strong>的总称</p><h4 id="货币政策工具"><a href="#货币政策工具" class="headerlink" title="货币政策工具"></a>货币政策工具</h4><ol><li><em><strong>公开市场操作</strong></em>：</li></ol><ul><li>央行购买债券<ul><li>将新货币直接或者间接注入银行$\rightarrow$增加了银行准备金$\rightarrow$增加可以创造的货币量</li></ul></li><li>央行出售债券<ul><li>公众使用M1购买债券$\rightarrow$减少流通中的货币数量$\rightarrow$减少了银行准备金$\rightarrow$减少可以创造的货币量</li></ul></li><li>优点： 易于进行，经常使用</li></ul><ol start="2"><li><em><strong>央行向银行房贷</strong></em></li></ol><ul><li>银行从央行的贴现窗口借款，并就贷款支付贴现率（discount rate）水平的利率。<br>  <font size = 2>Remark：贴现率被用于确定一笔未来的现金流的现值。</font></li><li>央行放贷$\to$银行准备金$\uparrow \to$货币供给$\uparrow$<ul><li>更高的贴现率(利率更高)：减少货币供给量</li><li>更低的贴现率(利率更低)：增加货币供给量</li></ul></li></ul>  </div>  <div><ul><li><strong>部分准备金银行</strong><ul><li>银行只持有一小部分存款作为准备金</li><li>银行行系统会创造货币，但不会创造财富</li><li>货币乘数：$m&#x3D;\frac{1}{R}$ </li><li>货币供给&#x3D;准备金$\times$货币乘数</li></ul></li></ul><hr><ol start="3"><li><em><strong>法定准备金</strong></em>：</li></ol><ul><li>规定银行持有<strong>最低的准备金量</strong><ul><li>增加法定准备金：减少货币供给（银行准备金$\downarrow$）</li><li>减少法定准备金：增加货币供给（银行准备金$\uparrow$）</li></ul></li><li>缺点： 扰乱银行业务，且银行持有超额准备金</li></ul><ol start="4"><li><em><strong>支付准备金利息</strong></em><br>支付准备金利息：央行向银行支付准备金利息 <ul><li>准备金利率越高，银行持有准备金越多，货币供给越少<br>  <font size = 2>Remark: 准备金率$\uparrow\to$货币乘数$\downarrow\to$货币供给$\downarrow$</font>   </div></div></li></ul></li></ol><h3 id="货币供给和通货膨胀"><a href="#货币供给和通货膨胀" class="headerlink" title="货币供给和通货膨胀"></a>货币供给和通货膨胀</h3><div style="display: grid; grid-template-columns: 1fr 1fr;">  <div><ol><li>定义$P&#x3D;$ 物价水平：一篮子物品与服务的价格<ul><li>$\frac{1}{P}$表示1单位能购买的物品与服务量（货币价格）<br>  <font size = 2>Remark：当整体物价水平上升时，货币价值下降</font></li></ul></li><li><strong>通货膨胀</strong>：$p\uparrow$ 货币价值 $\downarrow$<br> <strong>通货紧缩</strong>：$p\downarrow$ 货币价值$ \uparrow $</li></ol>  <img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305311456110.png">   </div>   <div><ul><li><p><strong>决定货币价值的因素</strong></p><ul><li>货币供给：由央行确定<ul><li>供给曲线是垂直的</li></ul></li><li>货币需求：反映人们希望以流动形式持有的财富量<ul><li>货币的需求曲线向下倾斜：较低的货币价值增加了货币的需求</li></ul></li></ul><p><br> $\Leftarrow$ 在均衡点A，货币价值（左轴）和物价水平（右轴）使货币供给量和货币需求量达到均衡。</p></li></ul>  </div></div><ul><li>从长远看物价总水平会调整到使货币需求等于货币供给的水平</li><li><strong>货币数量论</strong>：经济中可得到的<strong>货币量</strong>决定<strong>物价水平</strong>，可得到的货<br>币量的<strong>增长率</strong>决定<strong>通货膨胀率</strong>。<br><font size = 2>e.g. 货币供给$\uparrow$&#x2F;央行购买债券$\Rightarrow$货币供给曲线右移$\Rightarrow$货币价值$\downarrow$$\Rightarrow$物价水平$\uparrow$</font><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305311515240.png" height = 150></li><li>实际利率 &#x3D; 名义利率 - 通货膨胀率</li><li>根据古典二分法，名义变量受经济中货币制度发展的影响，而货币与解释真实变量基本无关</li></ul><h4 id="货币中性"><a href="#货币中性" class="headerlink" title="货币中性"></a>货币中性</h4><ul><li><strong>定义</strong>：货币供给量的变化不会影响实际变量（长期！！！）</li><li>定义<strong>货币流通速度</strong>$V$：货币易手速度 $Y$：实际GDP  $M$：货币数量<ul><li>有$P\times Y&#x3D;$ 名义GDP</li></ul></li><li>$V&#x3D;\frac{P\times Y}{M}$ <ul><li>注意其中V通常相对稳定，$Y&#x3D;F(K,L,H,N)$与$M$无关</li><li>货币供给量M的变化引起名义产出值的成比例变化 (P × Y)$\Rightarrow M\uparrow$时通货膨胀率高</li></ul></li></ul><p><strong>费雪效应</strong>： 增加的通货膨胀使得名义利率同比例增加，所以真实利率（关于财富水平）不变。</p><h4 id="通货膨胀的成本"><a href="#通货膨胀的成本" class="headerlink" title="通货膨胀的成本"></a>通货膨胀的成本</h4><ul><li>皮鞋成本：买家需要更频繁去银行，货币持有量减少（转换为投资等方式保值资产）</li><li>菜单成本：卖家需要承担改变价格的成本&amp;相对价格波动</li><li>税收扭曲：通货膨胀会夸大资本收益的规模，增加税收负担</li></ul><h2 id="二、总需求和总供给"><a href="#二、总需求和总供给" class="headerlink" title="二、总需求和总供给"></a>二、总需求和总供给</h2><h3 id="经济波动"><a href="#经济波动" class="headerlink" title="经济波动"></a>经济波动</h3><p>经济中的<strong>短期波动</strong>被称为<strong>经济周期</strong></p><ul><li>经济波动不规律且不可预测</li><li>大多数宏观变量会一起波动：投资支出的变化很大<ul><li>实际GDP是监测经济短期变动最常用的变量</li></ul></li><li>随着产量减少，失业率上升</li></ul><h3 id="AD-AS模型"><a href="#AD-AS模型" class="headerlink" title="AD-AS模型"></a>AD-AS模型</h3><div style = "display: grid; grid-template-columns: 1fr 1fr;">  <div><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305311750934.png" height = 200>  </div>  <div><p>  <strong>Remark</strong>:AD-AS模型中的数量——实际GDP，衡量了<strong>所有</strong>市场中的<strong>所有</strong>企业生产的商品和服务的总量。<br>  注意与微观的不同：从一个市场到另一个市场的微观经济替代对于整个经济来说是不可能的。<br>  </div></p></div><h4 id="为什么AD曲线向下倾斜？"><a href="#为什么AD曲线向下倾斜？" class="headerlink" title="为什么AD曲线向下倾斜？"></a>为什么AD曲线向下倾斜？</h4><p><strong>定义</strong>：$Y_{ield}&#x3D;C_{ost}+I_{nvestigate}+G_{overnment}+N_{et}Ex_{port}$</p><ul><li>价格水平和消费：<strong>财富效应</strong>(刺激消费品需求)<ul><li>价格水平下降$\Rightarrow$货币实际价值$\uparrow \Rightarrow$消费者更富有$\Rightarrow$消费支出增加$\Rightarrow$商品和服务需求量增加</li></ul></li><li>价格水平和投资：<strong>利率效应</strong>(刺激投资需求)<ul><li>价格水平下降$\Rightarrow$购物所需钱减少$\Rightarrow$存款增加$\Rightarrow$可供投资的资本增加$\Rightarrow$利率下降$\Rightarrow$更多借贷$\Rightarrow$投资增加</li></ul></li><li>价格水平和净出口：<strong>汇率效应</strong>(刺激净出口需求)<ul><li>价格水平下降$\Rightarrow$国内商品相对于国外商品更便宜$\Rightarrow$净出口增加$\Rightarrow$净出口需求增加</li></ul></li></ul><h4 id="AD曲线的移动"><a href="#AD曲线的移动" class="headerlink" title="AD曲线的移动"></a>AD曲线的移动</h4><ul><li><ol><li>**消费变化$C$**： 在给定的价格水平上改变人们想要消费多少的影响因素</li></ol><ul><li>政府减税$\Rightarrow$消费增加$\Rightarrow$AD曲线右移</li><li>经济前景悲观$\Rightarrow$消费减少$\Rightarrow$AD曲线左移</li></ul></li><li><ol start="2"><li>**投资变化$I$**： 在给定的价格水平上影响想要投资多少的因素</li></ol><ul><li>新技术产生$\Rightarrow$成本下降，增加投入$\Rightarrow$AD曲线右移</li><li>税收减少$\Rightarrow$投资增加$\Rightarrow$AD曲线右移</li><li>货币供给增加$\Rightarrow$利率下降（市场可贷资本增多）$\Rightarrow$投资增加$\Rightarrow$AD曲线右移</li></ul></li><li><ol start="3"><li>**政府采购的变化$G$**： 政策制定者在给定的价格水平上改变政府支出</li></ol><ul><li>修建新的道路$\Rightarrow$政府采购增加$\Rightarrow$AD曲线右移</li></ul></li><li><ol start="4"><li>**净出口变化$NX$**： 在给定的价格水平上影响净出口的因素</li></ol><ul><li>美元升值$\Rightarrow$美国商品在国外更贵$\Rightarrow$净出口减少$\Rightarrow$AD曲线左移</li><li>国外经济增长$\Rightarrow$国外商品需求增加$\Rightarrow$净出口增加$\Rightarrow$AD曲线右移</li></ul></li></ul><h4 id="流动性偏好理论"><a href="#流动性偏好理论" class="headerlink" title="流动性偏好理论"></a>流动性偏好理论</h4><p><font size = 2>Remark：价格变化最关键影响的是<strong>投资$I$<strong>；影响投资最关键的因素是利率 </font><br>流动性偏好理论详细解释了价格如何</strong>通过利率影响产出</strong>，从而把实际变量Y和价格联系在一起。</p><p><em>货币需求是关于利率的函数：</em></p><div style = "display: grid; grid-template-columns: 1fr 1fr;">  <div>    <ul><li>利率是人们持有货币的机会成本</li><li>向下倾斜：利率上升时（名义利率和实际利率在通胀不变时变化趋势一致）<ul><li>提高持有货币成本$\Rightarrow$货币需求减少</li></ul></li><li>货币供给：由央行控制，不随利率变化，可以平行移动  </div></li></ul>  <div>  <div align=right><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305312034553.png" height=180 width = 90%></div>  </div></div><p><em>货币市场均衡</em></p><ul><li>定义：通过利率调整，货币市场达到均衡</li><li>Case1： 利率$&gt;$均衡利率<ul><li>人们想要持有的货币数量$&lt;$ 供给数量 $\Rightarrow$现金过剩，人们购买有息资产$\Rightarrow$更多可贷资金$\Rightarrow$利率降低，持有货币机会成本降低$\Rightarrow$货币需求增加$\Rightarrow$货币市场均衡</li></ul></li><li>Case2：利率$&lt;$均衡利率<ul><li>人们想要持有的货币数量$&gt;$ 供给数量 $\Rightarrow$现金不足，人们卖出有息资产$\Rightarrow$更少可贷资金$\Rightarrow$利率升高，持有货币机会成本升高$\Rightarrow$货币需求减少$\Rightarrow$货币市场均衡</li></ul></li></ul><p><em><strong>用流动性偏好理论解释AD曲线向下倾斜</strong></em>：</p><div style = "display: grid; grid-template-columns: 1fr 1fr;"><div><ul><li><p>货币需求是关于利率(i)和价格（价格指数$\frac{1}{P}$）的函数：$M^d &#x3D; P \cdot L(i,Y)$</p></li><li><p>价格水平上升导致货币曲线向右移动</p></li><li><p>货币需求曲线右移导致利率上升</p></li><li><p>利率是借款成本，利率上升人们对商品的需求减少</p></div><div><div align=center><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305312112952.png" height = 180 width = 60%></div></div></div></li><li><p>通过货币政策影响AD：</p><ul><li>增大供给量&#x2F;降低利率$\Rightarrow$货币需求增加$\Rightarrow$AD曲线右移</li><li>减少供给量&#x2F;提高利率$\Rightarrow$货币需求减少$\Rightarrow$AD曲线左移</li></ul></li></ul><h4 id="总供给曲线AS"><a href="#总供给曲线AS" class="headerlink" title="总供给曲线AS"></a>总供给曲线AS</h4><ul><li>**长期总供给(LRAS)**：垂直，货币中性成立<ul><li>长期产品供给量取决于劳动力、资本、自然资源数量与技术，与价格水平无关</li><li>自然产出水平：一个经济体在长期中当失业处于其正常水平时候到达的物品和服务的生产水平</li><li>LRAS曲线的移动：$Y&#x3D;A\cdot F(L,K,H,N)$ <ul><li>所以$L_{abor}$,$K_{apital}$,$H_{uman;capital}$,$N_{atural;resources}$,$A_{vailable;technology}$的增加会导致LRAS曲线右移</li></ul></li></ul></li></ul><p>Remark：长期来看LRAS曲线不断右移（技术进步），AD曲线也不断右移（央行货币供给增加），<strong>产量持续增长，持续通胀</strong>。</p><ul><li>**短期总供给(SRAS)**：向上倾斜——经济有时会高于或低于其自然产出水平<ul><li>原因：价格调整需要时间</li><li>实际产出$Y&#x3D;Y_{N自然产出水平}+a(P_{实际价格水平}-P_{预期价格水平E});(a&gt;0)$</li></ul><ol><li>黏性工资理论: 价格水平下降，工资（成本）不变，企业利润增加，扩大生产</li><li>黏性价格理论：价格水平下降，企业价格还未改变，相对价格上升，销量减少生产减少</li><li>误解理论</li></ol><ul><li>SRAS的移动： $P_E$增加，AS左移；L、K、N、A的变化（同长期）</li></ul></li></ul><h4 id="经济波动的分析"><a href="#经济波动的分析" class="headerlink" title="经济波动的分析"></a>经济波动的分析</h4><div style = "display: grid; grid-template-columns: 1fr 1fr;"><div><p><strong>长期均衡：</strong></p><ul><li>AD 和 LRAS 曲线的交点决定了长期均衡</li><li>长期均衡时一定处在短期均衡，得到<br>  长期均衡时：$Y&#x3D;Y_N$，$P&#x3D;P_E$</div><div><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305312231738.png" height=150></div></div></li></ul><div style = "display: grid; grid-template-columns: 1fr 1fr;">  <div><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305312255093.png" height = 200 width = 95%>  </div>  <div><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305312300012.png" height = 200 width = 95%>  </div></div><h4 id="财政-x2F-货币政策影响AD曲线"><a href="#财政-x2F-货币政策影响AD曲线" class="headerlink" title="财政&#x2F;货币政策影响AD曲线"></a>财政&#x2F;货币政策影响AD曲线</h4><ul><li><strong>货币政策</strong>：央行调整货币供给量，影响利率，进而影响AD曲线（见上）</li><li><strong>财政郑策</strong>：政府决策者对政府支出和税收水平的调整来影响AD曲线<ul><li>扩张性财政政策：<strong>政府支出</strong>增加或<strong>税收</strong>减少，AD曲线右移</li><li>紧缩性财政政策：<strong>政府支出</strong>减少或<strong>税收</strong>增加，AD曲线左移</li><li>财政政策的额外影响：<ul><li>乘数效应：取决于边际消费倾向(MPC) MPC越大，乘数效应越大<br>支出乘数：$\frac{1}{1-MPC}$ 表示消费1元带来的额外的总需求的变化（总需求变化&#x3D; $\Delta G\times \frac{1}{1-MPC}$）</li><li>挤出效应：当扩张性财政政策引起利率上升，从而减少了投资支出时所引起的总需求的变化。<br><font size=2> Remark: 关键在于扩张性财政政策使得总产出增加，货币需求增加，进而使得利率上升，减少投资，使AD曲线略微左移。</font></li></ul></li></ul></li></ul><h4 id="财政政策影响AS曲线"><a href="#财政政策影响AS曲线" class="headerlink" title="财政政策影响AS曲线"></a>财政政策影响AS曲线</h4><p>主要体现在<strong>长期</strong><br>e.g. 政府提高教育水平，提高劳动力素质，提高LRAS曲线</p><h2 id="三、宏观经济学的一些公式"><a href="#三、宏观经济学的一些公式" class="headerlink" title="三、宏观经济学的一些公式"></a>三、宏观经济学的一些公式</h2><ul><li><strong>GDP</strong>：国内生产总值，一个国家一年内生产的所有最终产品和服务的市场价值<ul><li>GDP &#x3D; C + I + G + NX<br><font size=2> Remark: 转移支付（向老人支付社保金，向下岗工人支付失业保险金）和资产贬值不计入GDP；购房属于投资</font></li><li>GDP平减指数 &#x3D; $\frac{名义GDP}{实际GDP}\times 100$</li></ul></li><li><strong>通货膨胀率</strong>：第二年的通货膨胀率 &#x3D; $\frac{GDP_{第二年平减指数}-GDP_{第一年平减指数}}{GDP_{第一年平减指数}}\times 100%$</li><li><strong>CPI</strong>:一个篮子的成本<ul><li>CPI&#x3D;$\frac{当年篮子总费用}{基年篮子总费用}$</li><li>第二年通货膨胀率 &#x3D; $\frac{CPI_{第二年}-CPI_{第一年}}{CPI_{第一年}}\times 100%$</li></ul></li></ul><!-- # 微观部分 --><h2 id="四、完全竞争市场"><a href="#四、完全竞争市场" class="headerlink" title="四、完全竞争市场"></a>四、完全竞争市场</h2><ol><li><strong>厂商需求曲线</strong>水平（没有议价权），厂商需求弹性为无穷大</li><li><strong>市场需求曲线</strong>向右下方倾斜：市场中不同行业不能完全替代，市场中不同行业有价格决定权</li><li>完全竞争市场中厂商的收益曲线TR&#x3D;AR&#x3D;MR&#x3D;价格&#x3D;厂商需求曲线（<strong>四线合一</strong>）</li><li><strong>利润最大化的均衡条件</strong>：$MR&#x3D;MC$</li><li><strong>完全竞争市场的均衡</strong>：需求曲线和供给曲线的交点</li><li><strong>完全竞争厂商的均衡</strong>：<ul><li><strong>短期均衡</strong>：短期企业不能进入或退出，L可变，K不可变<ul><li>原则：MR&#x3D;MC&#x3D;P</li><li>厂商盈亏：$\pi&#x3D;(P-SAC)\cdot Q$ $\Rightarrow$ P&gt;SAC 厂商盈利；P&lt; SAC 厂商亏损 P&#x3D;SAC 不盈不亏</li><li>厂商停产决策：$\pi &#x3D;(P-AVC)\cdot Q-FC$ P&gt;AVC 继续生产；P&#x3D;AVC 停产点；P&lt; AVC 停止生产</li><li>短期厂商供给曲线是AVC之上的SMC曲线</li></ul></li><li><strong>长期均衡</strong>：厂商随意进入退出，K、L都可变 <ul><li>长期不能获得超额利润，只能获得正常利润（不赢不亏）</li><li>P&#x3D;LMC&#x3D;LAC&#x3D;SAC&#x3D;SMC</li><li>厂商的长期供给曲线是获得正常利润的一个点$p_0$</li><li>行业的长期供给曲线<ul><li>成本固定不变行业：水平直线</li><li>成本递增行业：右上方倾斜</li><li>成本递减行业：右下方倾斜</li></ul></li></ul></li></ul></li></ol><h2 id="五、完全垄断市场"><a href="#五、完全垄断市场" class="headerlink" title="五、完全垄断市场"></a>五、完全垄断市场</h2><ol><li><p>整个行业只有唯一的厂商生产和销售产品，没有替代品，其他厂商难以进入该行业</p></li><li><p><strong>垄断厂商的需求曲线</strong>向右下方倾斜<br> <font size=2> Remark: 完全垄断厂商不能随便定价，其定价是为了收益最大化</font></p></li><li><p><strong>垄断厂商的收益曲线：</strong></p><ul><li>垄断厂商的需求曲线是其收益曲线（$AR&#x3D;\frac{TR}{Q}&#x3D;P(Q)$）</li><li>边际收益：设$P&#x3D;a-bQ$，则MR&#x3D;$a-2bQ$（边际收益的斜率是需求曲线的两倍）<br><font size=2>（结论：中点以上需求弹性大于1，中点以下需求弹性小于1）</font></li></ul></li><li><p><strong>垄断厂商的短期均衡</strong> </p><ul><li>条件：$MR&#x3D;MC$</li><li>短期均衡的三种情况：P&gt;AC 厂商盈利；P&lt; AC 厂商亏损；P&#x3D;AC 厂商不盈不亏<br><font size=2>1.MR&#x3D;MC找到Q 2. 在AR（需求曲线）上找到对应P 3. 判断P与SAC关系</font></li></ul></li></ol><ul><li>完全垄断厂商不存在供给曲线：Q与P不是一一对应关系</li></ul><ol start="5"><li><strong>垄断厂商的长期均衡</strong> MR&#x3D;LMC&#x3D;SMC<ul><li>厂商可以获得超额利润</li></ul></li><li><strong>价格歧视</strong>：<ul><li>一级（完美）价格歧视：厂商可以根据不同的消费者收取不同的价格（价格等于支付意愿）获得全部消费者剩余</li><li>二级价格歧视：厂商可以根据不同的消费量收取不同的价格（数量折扣）</li><li>三级价格歧视：厂商以不同价格出售给不同人群（老年人折扣、学生折扣）</li></ul></li><li><strong>自然垄断</strong>： 由于<strong>规模经济</strong>，当一家公司可以为整个市场提供商品或服务，其成本会低于两家或多家公司一起提供该产品（固定成本大而边际成本小）</li><li><strong>对垄断的公共政策</strong>：反垄断法；规制；政府经营；无作为</li></ol><h2 id="六、垄断竞争市场"><a href="#六、垄断竞争市场" class="headerlink" title="六、垄断竞争市场"></a>六、垄断竞争市场</h2><ol><li>市场中有许多厂商在销售相类似但又不完全相同的商品（e.g.小说市场）</li><li>特征<ul><li>厂商对市场的影响有限</li><li>各厂商生成的商品存在差别</li><li>厂商进入或退出行业比较容易</li></ul></li><li>短期垄断竞争：类似于完全垄断</li><li>长期垄断竞争：厂商可以<strong>自由进出</strong>，所以只能获得正常利润<ul><li>ATC与需求曲线相切，ATC&#x3D;MC&#x3D;MR&#x3D;P</li></ul></li></ol><h2 id="七、寡头垄断市场"><a href="#七、寡头垄断市场" class="headerlink" title="七、寡头垄断市场"></a>七、寡头垄断市场</h2><p>一些概念和定义：</p><ul><li><strong>寡头垄断</strong>：只有少数几个卖者提供相似或相同产品的市场结构<ul><li>寡头企业之间的策略是相互依赖的：任何企业的策略都会影响其他企业的策略</li></ul></li><li><strong>双寡头垄断</strong>：市场里只有两个企业的寡头垄断<ul><li>双方各自确定要出售的数量，然后根据市场需求曲线确定价格</li><li>共谋：市场上公司之间关于生产数量或收费价格的协议。</li><li>卡特尔：一群一致行动的公司。<br><font size=2>Remark:如果没有形成卡特尔，每个公司需要考虑产出效应和价格效应，直至两个边际效应完全平衡。</font></li></ul></li><li><strong>纳什均衡</strong>：鉴于所有其他参与者选择的策略, 每个人都选择各自最好的策略<ul><li>占优策略：无论其他参与者选择什么策略，对一个参与者都为最优的策略</li></ul></li><li>寡头垄断（双寡头垄断）的平衡可以使用<strong>最佳反馈</strong>的方法得出。（双方共同最佳）<ul><li>考虑给定你选择的策略（数量） x ，其他公司的最佳反馈是什么</li><li>求解x 使得你自己的利润最大化的</li></ul></li></ul><h2 id="八、经济学概论"><a href="#八、经济学概论" class="headerlink" title="八、经济学概论"></a>八、经济学概论</h2><p>经济学（economics）研究社会<strong>如何管理&#x2F;支配稀缺</strong>的资源</p><ul><li>个体如何做出决策：<ul><li><strong>原理1</strong>：人们在做决策的时候面临权衡取舍</li><li><strong>原理2</strong>：得到某样东西的成本是为了得到它所放弃的东西的价值<ul><li>机会成本：为了得到某种东西所必须放弃的东西<br> <font size=2> Remark:放弃的机会中收益最高的项目才是机会成本,即机会成本不是放弃项目的收益总和</font></li></ul></li><li><strong>原理3</strong>：理性人考虑边际量</li><li><strong>原理4</strong>：人们会对激励做出反应<ul><li>激励（incentives）是引起一个人做出某种行为的某种东西（例如惩罚或奖励的预期）</li></ul></li></ul></li><li>人们如何相互影响:<ul><li><strong>原理5</strong>：市场通常是组织经济活动的一种好方法，但市场也会失灵。<ul><li>“看不见的手”<strong>通过价格体系来发挥作用</strong></li></ul></li></ul></li><li>整体经济如何运行<ul><li><strong>原理6</strong>：国家的生活水平取决于它生产物品与服务的能力</li></ul></li></ul><h2 id="九、贸易与比较优势"><a href="#九、贸易与比较优势" class="headerlink" title="九、贸易与比较优势"></a>九、贸易与比较优势</h2><ol><li><strong>生产可能性边界</strong>：表明了在考虑到可用的生产要素和生产技术下，经济可能产生的产出组合<ul><li>沿着生产可能性边界的任何点都是<strong>有效率</strong>的</li><li>斜率表示X的机会成本；$\frac{1}{斜率}$表示Y的机会成本</li><li>技术进步，生产可能性边界向外移动</li></ul></li><li><strong>比较优势</strong>：比其他生产者更低的机会成本生产商品的能力</li></ol><h2 id="十、需求与供给"><a href="#十、需求与供给" class="headerlink" title="十、需求与供给"></a>十、需求与供给</h2><ol><li><p>求市场需求函数：将所有消费者的需求函数相加<br> <font size=4> Remark:做题时相加的应该是$Q&#x3D;f(P)$的函数，不能直接将$P&#x3D;f(Q)$的函数相加</font></p></li><li><p><strong>支付意愿</strong>：个人愿意为某种商品支付的<strong>最高金额</strong></p></li><li><p><strong>需求量增加</strong>：沿着需求曲线向右移动<br><strong>需求增加</strong>：价格减小，需求曲线向右移动</p></li><li><p><strong>正常物品</strong>：在其他条件相同时，收入减少引起需求量减少的物品<br><strong>低档物品</strong>：在其他条件相同时，收入减少引起需求量增加的物品</p></li><li><p><strong>替代品</strong>：两种物品的需求量负相关；互补品：两种物品的需求量正相关</p></li><li><p><strong>供给意愿</strong>：生产者愿意出售一件商品的最低价格</p></li><li><p><strong>均衡</strong>：市场价格达到使供给量与需求量相等时的状态</p><ul><li>均衡价格：市场出清价格，买者买到了所有想买的商品，卖者卖出了所有想卖的商品</li></ul></li></ol><h2 id="十一、弹性"><a href="#十一、弹性" class="headerlink" title="十一、弹性"></a>十一、弹性</h2><ol><li><strong>需求价格弹性</strong>：$e&#x3D;\frac{需求量变化的百分比}{价格变化的百分比}&#x3D;\frac{\Delta Q&#x2F;Q}{\Delta P&#x2F;P}&#x3D;\frac{\Delta Q}{\Delta P}\frac{P}{Q}$<ul><li>商品的需求量对该物品价格变化的反应程度，曲线越平坦，弹性越大</li><li>价格低、数量大的点需求价格弹性小，反之亦然</li><li>决定因素：<ul><li>替代品可获得性越大$\Rightarrow$弹性越大；</li><li>必需品缺乏弹性，奢侈品富有弹性</li><li>市场定义越窄$\Rightarrow$弹性越大</li><li>物品需求在长期更具有弹性</li></ul></li><li>中点法计算：$e&#x3D;\frac{\frac{Q_2-Q_1}{\frac{Q_2+Q_1}{2}}}{\frac{P_2-P_1}{\frac{P_2+P_1}{2}}}$</li></ul></li><li><strong>总收益和价格弹性</strong>：$TR&#x3D;P\times Q$<ul><li>当需求价格弹性$e&gt;1$时，P和TR同向运动</li><li>当需求价格弹性$e&lt;1$时，P和TR反向运动</li><li>当需求价格弹性$e&#x3D;1$时，TR不变</li></ul></li><li><strong>需求的交叉价格弹性</strong>：一种商品的需求量对另一种商品价格变化的反应程度<ul><li>替代品：交叉价格弹性大于0</li><li>互补品：交叉价格弹性小于0</li></ul></li><li><strong>供给曲线</strong>：低价格和低数量的点弹性大（考虑斜率）</li><li><strong>弹性对价格管制</strong>：较大的弹性导致更大的需求缺口</li><li><strong>弹性对税收</strong>：更高弹性的一方承担更少的税收负担；同时更高的弹性会导致更大的无谓损失（考虑极限状态）</li></ol><h2 id="十二、福利经济学"><a href="#十二、福利经济学" class="headerlink" title="十二、福利经济学"></a>十二、福利经济学</h2><ol><li><strong>消费者剩余</strong>：支付意愿 - 支付的价格</li><li><strong>生产者剩余</strong>：价格 – 成本</li><li><strong>总剩余</strong>：消费者剩余 + 生产者剩余&#x3D;支付意愿 - 成本<ul><li>效率：使社会所有成员获得的总剩余最大化的资源配置方式</li></ul></li><li>市场是有效的前提：完全竞争、没有外部性<img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202306011958086.png" height = 200></li></ol><h2 id="十三、公共物品与公共资源"><a href="#十三、公共物品与公共资源" class="headerlink" title="十三、公共物品与公共资源"></a>十三、公共物品与公共资源</h2><div style = "display: grid; grid-template-columns: 1fr 1fr;">   <div><ul><li>物品的两个重要特征<ul><li>排他性：以阻止其他人使用它的特性</li><li>消费中的竞争性：减少其他人的使用该物品的属性  <div align = right><font size=2></li></ul></li></ul><p>  基础研究是公共物品$\Rightarrow$</font></div><br>  </div><br>  <div><br> <img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202306012013313.png" height = 170><br>  </div></p></div><ul><li><p>公共物品的搭便车问题：非排他性$\Rightarrow$市场无法打到效率最大化$\Rightarrow$市场失灵</p><ul><li>解决方式：政府用税收来支付，提供公共物品（税收资助的反贫困计划）</li></ul></li><li><p>公共资源：消费中的竞争性$\Rightarrow$过度使用产生负外部性</p></li></ul><h2 id="十四、外部性"><a href="#十四、外部性" class="headerlink" title="十四、外部性"></a>十四、外部性</h2><ol><li><strong>外部性</strong>：一个人的行为对旁观者福利的无补偿影响、</li><li><strong>负外部性</strong>：市场均衡的数量大于社会合意的数量<ul><li>社会成本 &gt; 商品生产者的私人成本：工业污染</li><li>社会价值 &lt; 消费者的私人价值：抽烟</li><li>解决方式：外部性内在化（e.g.对卖者征税，使市场参与者必须支付社会成本）</li></ul></li><li><strong>正外部性</strong>：市场均衡的数量小于社会合意的数量<ul><li>社会价值&gt;私人价值（教育、疫苗）</li><li>解决方式：补贴</li></ul></li><li><strong>针对外部性的公共政策</strong>：以二氧化碳排放为例<ul><li>命令和控制：强制减排多少吨</li><li>矫正税（庇古税）：：每个企业想生产多少就生产多少，但每排放一吨，就要交一定税。（设定污染价格）<ul><li>通常边际减排成本在污染减排中是增加的，税收↑减少污染↑。</li><li>优点：矫正税在为政府增加收入的同时，也提高了经济效率</li></ul></li><li>可交易排污许可证（限制污染数量）<ul><li>优点：排污许可证的初始分配无关紧要；不需要知道确切的边际减排成本</li></ul></li></ul></li><li><strong>针对外部性的私人政策</strong><ul><li>科斯定理：如果利益各方可以在资源分配上无成本地讨价还，他们<strong>可以自己解决外部性问题</strong>，无论最初的权利分配如何，利益各方可以通过讨价还价使得<strong>每个人都过得更好</strong>，<strong>结果是有效率的</strong></li><li>科斯定理的三个条件：谁拥有所有权，讨价还价几乎没有成本，只有少数利益相关者</li></ul></li><li><strong>市场失灵的本源</strong>：外部性自身不一定导致市场失灵，需要同时伴随产权不清或交易成本过高</li></ol><hr><p>$\color{transparent}{写在最后：Cheatsheet到底是哪个若只想出来的nt设定！！！这个半开卷，就给nm一张A4纸，复习起来工作量翻好几倍，焯}$</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS100期末Review</title>
    <link href="/2023/05/14/CS100%E6%9C%9F%E6%9C%ABReview/"/>
    <url>/2023/05/14/CS100%E6%9C%9F%E6%9C%ABReview/</url>
    
    <content type="html"><![CDATA[<h1 id="CS100期末Revision"><a href="#CS100期末Revision" class="headerlink" title="CS100期末Revision"></a>CS100期末Revision</h1><p>写在前面：这个文档是我在复习CS100期末考试的时候整理的，主要是对于自己一些不熟悉的知识点的整理，并非对于CS100知识点的全面复习。同时，本文可能会有一些错误，如果发现错误，欢迎指出。</p><hr><h2 id="1-区分底层const和顶层const"><a href="#1-区分底层const和顶层const" class="headerlink" title="1. 区分底层const和顶层const"></a>1. 区分底层<code>const</code>和顶层<code>const</code></h2><ul><li>顶层<code>const</code>：指针本身是个常量, 指针所指的对象不是常量（指针不可以指向别的对象，但是可以改变所指对象的值）</li><li>底层<code>const</code>：指针所指的对象是一个常量（指针可以指向别的对象，但是不可以改变所指对象的值）<br><em>e.g.</em><br>[1].<code>const int* const p</code>:第一个const是底层const，第二个是顶层const<br>[2].<code>const char&amp; operator[](int index) const</code>:第一个const是底层const，第二个const是加在<code>this</code>指针上的底层const,表示对象的所有成员都是常量，<strong>不可以被改变！！！</strong></li></ul><p><strong>Remark:</strong> <em>为什么对一个类要定义<code>[]</code>运算符const和non-const两个版本的重载？</em><br>const对象只能调用const成员函数，而non-const对象可以调用const和non-const成员函数，所以为了让const对象也能调用<code>[]</code>运算符，就要定义const版本的<code>[]</code>运算符重载。如果a本身就带const，而fun不是const成员函数，那这个调用就是在试图去除底层const，这是不允许的。</p><h2 id="2-C-amp-C-中的运算符"><a href="#2-C-amp-C-中的运算符" class="headerlink" title="2. C&amp;C++中的运算符"></a>2. C&amp;C++中的运算符</h2><ul><li><code>/</code> int&#x2F;int <strong>为向零取整</strong></li><li><code>%</code> 满足 <strong>(a &#x2F; b) * b + a % b &#x3D;&#x3D; a</strong></li><li><code>||</code>和<code>&amp;&amp;</code>是<strong>短路求值</strong>：(short-circuited)：先求左边，如果左边的结果能确定表达式的结果，就不再对右边求值。</li><li><code>,</code> 先对左边求值，再对右边求值，<strong>返回右边的值</strong></li><li>运算符的<strong>优先级</strong>和<strong>结合性</strong>不会决定求值顺序<br><em>e.g</em>:<br><code>f() - g() + h()</code> 中的 <code>f()</code>，<code>g()</code> 和 <code>h()</code> 的调用顺序是 unspecified 的。<br><code>f() + g() * h()</code> 中的 <code>f()</code>，<code>g()</code> 和 <code>h()</code> 的调用顺序是 unspecified 的。<br><strong>Remark:</strong> 只有<code>&amp;&amp;</code>, <code>||</code>, <code>?:</code>,<code>,</code>的求值顺序是确定的，其他的都是unspecified的。</li></ul><h2 id="3-变量的声明和初始化"><a href="#3-变量的声明和初始化" class="headerlink" title="3. 变量的声明和初始化"></a>3. 变量的声明和初始化</h2><ul><li>空初始化<blockquote><p>对于全局 (global) 或者局部静态 (local static) 变量，不显式初始化的情况下执行<strong>空初始化</strong><br>对于局部非静态 (local non-static) 变量，不显式初始化的情况下将持有<strong>未定义的值</strong>：你不能对它的值作任何假定，<strong>使用未定义的值的行为是未定义的行为</strong><br>对于类内成员的默认初始化（调用默认构造函数）在未指定默认值时的值是<strong>未定义的值</strong></p></blockquote></li></ul><h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4. 指针"></a>4. 指针</h2><ul><li>指针的值是一个<strong>地址</strong>，这个地址指向某个对象</li><li><code>p + i</code> 得到的地址是 <code>(void *)p + i * sizeof(Type)</code>，即和 <code>p</code> 相距 <code>i</code> 个 <code>Type</code>。</li><li>如果指针 <code>p1</code> 和 <code>p2</code> 分别指向某一个数组的下标为 <code>i</code> 和 <code>j</code> 的位置，则 <code>p1 - p2</code><ul><li>结果是 <code>i - j</code>，</li><li>类型为 <code>ptrdiff_t</code>：一个定义在 <code>&lt;stddef.h&gt;</code> 里的类型，是一种带符号整数，其具体大小是 implementation-defined。</li></ul></li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul><li>数组指针：<code>int (*p)[10]</code> 指向一个含有10个整数的数组</li><li>指针数组：<code>int *p[10]</code> 含有10个指向整数的指针的数组<br><strong>Remark:</strong> <em>如何理解 二维数组<code>int a[m][n]</code>？</em></li></ul><ol><li>一个指向<code>int[n]</code>的指针，即 <code>int (*p)[n]</code>。</li><li>存放了 <code>m</code> 个数组的地址，每个数组有 <code>n</code> 个 <code>int</code>，即 <code>int *p[m]</code>。（二维数组退化<em>degrade</em>为指向首元素<code>int [m]</code>的数组）</li></ol><h2 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h2><ul><li>字符串字面值：类似这种 <code>&quot;abcde&quot;</code>（<strong>双引号！！！</strong>）<ul><li>C：类型为 <code>char [N+1]</code>，其中 <code>N</code> 是它的长度，<code>+1</code> 是为了放空字符。</li><li>C++：类型为 <code>const char [N+1]</code></li></ul></li><li><code>&#39;a&#39;</code>的字符串字面值类型<ul><li>C：<code>int</code></li><li>C++：<code>char</code></li></ul></li></ul><h3 id="lt-string-h-gt-的函数"><a href="#lt-string-h-gt-的函数" class="headerlink" title="&lt;string.h&gt;的函数"></a><code>&lt;string.h&gt;</code>的函数</h3><ul><li><code>strcmp(s1, s2)</code> 按字典序 (lexicographical order) 比较两个字符串的大小。<ul><li>如果 <code>s1</code>“小于”<code>s2</code>，返回<strong>一个负数</strong></li><li>如果相等，返回 <code>0</code></li><li>如果 <code>s1</code>“大于”<code>s2</code>，返回<strong>一个正数</strong></li><li><strong>不可以认为它的返回值 $\in{-1,0,1}$！！！</strong></li></ul></li><li><code>strcpy(to, from)</code> 将 <code>from</code> 的内容拷贝给 <code>to</code>。</li></ul><h3 id="lt-string-gt"><a href="#lt-string-gt" class="headerlink" title="&lt;string&gt;"></a><code>&lt;string&gt;</code></h3><ul><li><strong>默认初始化一个 <code>std::string</code> 对象会得到空串，而非未定义的值！</strong></li><li>字符串的IO：<ul><li><code>std::cin</code>  会忽略开头的空白字符，直到遇到下一个空白字符为止。</li><li><code>getline(std::cin, s)</code> 会读入一整行，包括开头的空白字符，直到遇到换行符为止。</li></ul></li></ul><h2 id="6-Class"><a href="#6-Class" class="headerlink" title="6. Class"></a>6. Class</h2><ul><li><code>this</code> 指针：指向当前对象的指针，是一个隐式参数，<strong>只</strong>在<strong>成员函数内部</strong>使用。<ul><li>特别的，static成员函数没有this指针，以<code>class::static_func()</code>调用。</li></ul></li><li>构造函数通常是重载（<em>Overload</em>）的，构造函数不声明返回值类型，可以含有 <code>return;</code> 但不能返回一个值，<strong>但不能认为它的返回值类型是 <code>void</code>。</strong><ul><li>重载匹配规则：<strong>最佳匹配</strong>（Best Match） <img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305141612477.png"   width="50%"></li></ul></li></ul><h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（<em>Singleton</em>）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  <span class="hljs-comment">// 构造函数是 private 的</span><br>  <span class="hljs-built_in">Widget</span>();<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget &amp;) = <span class="hljs-keyword">delete</span>;<br>  Widget &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget &amp;) = <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-comment">// Magic happens here!!</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> Widget &amp;<span class="hljs-title">get_instance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> Widget w; <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="继承和多态（Inheritance-and-Polymorphism）"><a href="#继承和多态（Inheritance-and-Polymorphism）" class="headerlink" title="继承和多态（Inheritance and Polymorphism）"></a>继承和多态（<em>Inheritance and Polymorphism</em>）</h3><ul><li>父类的<strong>所有成员</strong>（除了构造函数和析构函数）都被继承下来，无论能否访问。（<em>private</em>成员也被继承下来，只是不能访问而已）</li><li>向上转型：<code>Base *p = &amp;derived;</code>(由派生类指针转换为基类指针)</li><li>向下转型：<code>dynamic_cast&lt;Derived *&gt;(p)</code>(由基类指针转换为子类指针):如果不能成功，<code>dynamic_cast&lt;T*&gt;</code> 返回空指针，<code>dynamic_cast&lt;T&amp;&gt;</code> 抛出 <code>std::bad_cast</code> 异常。</li></ul><h3 id="符号重载（Operator-Overload）"><a href="#符号重载（Operator-Overload）" class="headerlink" title="符号重载（Operator Overload）"></a>符号重载（<em>Operator Overload</em>）</h3><ul><li><code>++i</code> 返回 <code>i</code> 的引用，<code>i++</code> 返回递增前的 <code>i</code> 的一份拷贝。<ul><li><code>++i</code>：<code>class &amp;operator++()</code></li><li><code>i++</code>：<code>class operator++(int)</code> 其中 <code>int</code> 是一个不被使用的形参，用于区分前置和后置。</li></ul></li><li>赋值、复合赋值都返回左侧运算对象的引用。</li><li>IO运算符：这两个运算符只能是非成员：你无法给 <code>std::istream</code> 和 <code>std:ostream</code> 添加成员。<ul><li><code>std::istream &amp;operator&gt;&gt;(std::istream &amp;, Rational &amp;r);</code></li><li><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const Rational &amp;r);</code></li></ul></li></ul><h2 id="7-客观题知识点整理"><a href="#7-客观题知识点整理" class="headerlink" title="7. 客观题知识点整理"></a>7. 客观题知识点整理</h2><ul><li>Hw5:<ul><li>Q4: <code>&amp;a</code>返回lvalue，<code>a[3]</code>,<code>*a</code>都是rvalue。</li><li>Q7: std::string s3(); 是函数声明，而非定义空字符串。</li><li>Q9: <code>std::vector v;</code>声明一个vector时必须指定元素类型，或者给出足够条件使得编译器能够推断出元素类型。</li><li>Q10: 永远不能去除底层<code>const</code></li><li>Q12: <code>sizeof()</code>在编译时求值</li><li>Q14：<code>int fun(std::vector&lt;int&gt;)</code>,<code>int fun(std::vector&lt;double&gt;)</code>构成重载。</li></ul></li><li>Hw6:<ul><li>Q7:对于一个类，value-initialization就是default-initialization，调用默认构造函数(大部分情况，在某些情况下会调用zero-initialization)。</li><li>Q8: <code>int* ptr = nullptr; delete[] ptr;</code> &#x2F;&#x2F; 是合法的</li><li>Q10：const成员函数的const是加在<code>this</code>指针上,所以类内的<code>int*</code>指针会被视为<code>int* const</code>，而非<code>const int*</code>，可以修改指针指向的内容。</li><li>Q12：编译器执行析构函数时是在<strong>函数体之后</strong>销毁成员</li><li>Q14：Dynarray中在让<code>m_storage</code>指向新的内存之前，应该先释放原来的内存。(移动赋值和拷贝赋值)</li><li>Q18: unique_pointer只能移动，不能拷贝。</li><li>Q19：拷贝一个shared_ptr会增加引用计数，而不会拷贝指向的对象。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>知识整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2023/05/11/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/05/11/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="My-First-Blog–-By-KesonStar"><a href="#My-First-Blog–-By-KesonStar" class="headerlink" title="My First Blog– By KesonStar"></a>My First Blog– By KesonStar</h1><p>第一次发博客，不知道该写些什么，就想到哪里写到哪里，顺便测试一些功能吧</p><h2 id="我为什么想到要搭建一个自己的博客？"><a href="#我为什么想到要搭建一个自己的博客？" class="headerlink" title="我为什么想到要搭建一个自己的博客？"></a>我为什么想到要搭建一个自己的博客？</h2><p>其实最主要的关键就是一个，够<strong>酷</strong>！</p><p>一个以自己名字命名的域名，一个自己搭建的博客，一个自己写的博客，这真的是<em>泰裤辣</em>！</p><p>一切要从看到<a href="https://www.bilibili.com/video/BV1ts4y1f7Gu/">这个视频</a>开始说起（偷偷测试一下图片和链接的功能xx）<br><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305112335352.png"><br>其实我在三月份就已经刷到过了，但是那个时候我甚至连markdown的基本语法都不会，(被劝退后直接收藏退出一气呵成~)但是随着一学期自己到处折腾vscode写md，折腾git和github，我发现我已经具备了去搭建一个自己博客的知识储备。<br>搭建一个自己域名的博客不是一件容易的事，从最开始有这个想法到hexo的配置，域名和图床的建立，从本地到最后部署，前后有将近<strong>一个多月</strong>的时间。以后有机会可能会发一篇博客来记录一下这整个搭建的过程。</p><h2 id="这个博客以后会写些什么？"><a href="#这个博客以后会写些什么？" class="headerlink" title="这个博客以后会写些什么？"></a>这个博客以后会写些什么？</h2><p>就像title中写的那样——<em>For learning and life</em><br>上了大学，不再像高中一样有高考这一个唯一的目标，也就不再有以前那样督促自己去不断卷卷卷的内驱力了。大一的第一学期真的一晃而过，作为资深<strong>宿舍死宅</strong>，几乎每天都是宿舍、教中的两点一线，最多再加个图书馆。到底自己学到了什么，生活中发生了什么，感觉<em>眼中了了，心下匆匆</em>。<br>所以博客就是为了记录自己身边发生的事，记录自己的学习和生活，记录自己的成长。<br>我以后可能会随便发一些</p><ul><li>编程方面的学习笔记</li><li>以后一些leetcode和洛谷的题解</li><li>生活的随笔和感想（这个可能不会太多，好不容易和语文saygoodbye了）<br><img src="https://imghubforks-1318113821.cos.ap-shanghai.myqcloud.com/202305112349696.jpg">（ 这个表情包怎么这么大，以后得研究一下怎么把图片大小设置一下）</li><li>看的番和小说的感想</li></ul><p>最后偷偷测试一点功能<br>代码块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>公式：<br>$\lim_{x \to \infty} x^2_{2} - \int_{1}^{5}x\mathrm{d}x + \sum_{n&#x3D;1}^{20} n^{2} &#x3D; \prod_{j&#x3D;1}^{3} y_{j}  + \lim_{x \to -2} \frac{x-2}{x}$</p><p>最后还有一个评论的功能，不知道能不能用，先试试吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>Intro</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
